Use Configure Server to read properties from external repo:

1. Create folder (config-repo) out of current project and init git inside:
    git init .
    git remote add origin <path to new git repo>
2. Create project/module server-config.
    see server-config for more details
    application.prop change to bootstrap.prop
    bootstrap.properties: add this:
        server.port=8888
        spring.cloud.config.server.git.uri=file://${user.home}/<path to config-repo>
3. Alter existing service:
    Change app.prop to bootstrap.
    Add:
        spring.application.name=<service-name>
        spring.cloud.config.uri=http://localhost:8888
    Move prop to config-repo (to <service-name>.properties)
4. Run servcer-config and after that this service. Go to http://localhost:8888/<service-name>/default to see properties
------------------------------------------------------------------------------------------------------------------------

Refreshing properties:

If prop was changed, do not rerun config-server or service.
Call from terminal!!! curl -d {} http://<service-host-port>/refresh
If many instances of this service are running: curl -d {} http://<service-host-port>/bus/refresh
It will refresh properties
------------------------------------------------------------------------------------------------------------------------

Integration with Eureka

1. In Application add @EnableDiscoveryClient
2. Add dependency:
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-eureka</artifactId>
        </dependency>
3. In Config repo:
    for each service add: eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/
4. Create EurekaService:
    Add eureka server, actuator, cloud config dependencies
    In bootstrap.prop:
        spring.application.name=eureka-server-1
        server.port=8761
        spring.cloud.config.uri=http://localhost:8888
    In App: add @EnableEurekaServer
------------------------------------------------------------------------------------------------------------------------

Create api gateway

1. Create new property files per service, and check in to the Git repositories.
2. Change application.properties to bootstrap.properties, and add the required configurations.
3. Add @EnableZuulProxy to Application.java in each of the *-apigateway projects.
4. Add @EnableDiscoveryClient in all the Application.java files under each of the *-apigateway projects.
5. Optionally, change the package names and file names generated by default.
------------------------------------------------------------------------------------------------------------------------

Logging
1. Download Elasticksearch, Kibana, Logstash
2. Add dependency to microservice:
        <dependency>
            <groupId>net.logstash.logback</groupId>
            <artifactId>logstash-logback-encoder</artifactId>
            <version>4.6</version>
        </dependency>
3. Downgrade logback
        <logback.version>1.1.6</logback.version>
4. Override logback.xml
5. Create logstash.conf
6. Run logstash, elasticksearch, kibana

./bin/logstash -f logstash.conf
./bin/elasticsearch
./bin/kibana

7. Go to localhost:5601
------------------------------------------------------------------------------------------------------------------------

Run everything in Docker:
1. For each microservice add Dockerfile:

FROM frolvlad/alpine-oraclejdk8
VOLUME /tmp
ADD  target/<name_in_target>.jar <desired_name>.jar
EXPOSE 8001
ENTRYPOINT ["java","-jar","/<desired_name>.jar"]

2. In root of each microservice:

docker build -t <desired_name>:<version> .
docker run -d -p <port>:<mapping_port> <service_name (desired_name with version)>

docker build -t search:1.0 .


3. For config server docker run:
docker run -d -v <host_path_dir_to_config>:<docker_dir> -p <port>:<mapping_port> <service_name (desired_name with version)>
in config server props change:
spring.cloud.config.server.git.uri=file://<docker_dir>

for our services:
docker run -d -p 8888:8888 config-server:1.0
docker run -d -v /Users/igordumchykov/Projects/Tutorials/microservices/config-repo:/app -p 8888:8888 config-server:1.0
docker run -d -p 8761:8761 eureka-server:1.0
docker run -d rabbitmq:3
docker run -d -p 8090:8090 search:1.0
docker run -d -p 8095:8095 search-apigateway:1.0
docker run -d -p 8070:8070 checkin:1.0
docker run -d -p 8080:8080 fares:1.0
docker run -d -p 8060:8060 book:1.0
docker run -d -p 8001:8001 webface:1.0

or:

docker run --net host -p 8888:8888 config-server:1.0
docker run --net host  -v /Users/igordumchykov/Projects/Tutorials/microservices/config-repo:/app -p 8888:8888 config-server:1.0
docker run --net host  -p 8761:8761 eureka-server:1.0
docker run --net host  rabbitmq:3
docker run --net host  -p 8090:8090 search:1.0
docker run --net host  -p 8095:8095 search-apigateway:1.0
docker run --net host  -p 8070:8070 checkin:1.0
docker run --net host  -p 8080:8080 fares:1.0
docker run --net host  -p 8060:8060 book:1.0
docker run --net host  -p 8001:8001 webface:1.0

kill all:
docker stop $(docker ps -aq)

The new networking feature allows you to connect to containers by their name, so if you create a new network, any container connected to that network can reach other containers by their name. Example:

1) Create new network

$ docker network create <network-name>
2) Connect containers to network

$ docker run --net=<network-name> ...
or

$ docker network connect <network-name> <container-name>
3) Ping container by name

docker exec -ti <container-name-A> ping <container-name-B>

64 bytes from c1 (172.18.0.4): icmp_seq=1 ttl=64 time=0.137 ms
64 bytes from c1 (172.18.0.4): icmp_seq=2 ttl=64 time=0.073 ms
64 bytes from c1 (172.18.0.4): icmp_seq=3 ttl=64 time=0.074 ms
64 bytes from c1 (172.18.0.4): icmp_seq=4 ttl=64 time=0.074 ms
------------------------------------------------------------------------------------------------------------------------
